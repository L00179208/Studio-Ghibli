name: Terraform CI/CD

on:
  push:
    branches:
      - dev-sec-ops-process
  pull_request:
    branches:
      - dev-sec-ops-process

env:
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

jobs:
  code-scanning-sonarcloud:
    name: SonarCloud
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information, if any
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  build-and-push-images:
    name: 'Build and Push Docker Images'
    runs-on: ubuntu-latest
    needs: [code-scanning-sonarcloud]
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker images
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e

          build_and_push() {
            local service_directory=$1
            local service_name=$2

            if [ -d "$service_directory" ]; then
              cd $service_directory
              docker build -t $DOCKER_USERNAME/sgproject:$service_name -f Dockerfiles/Dockerfile .
              docker tag $DOCKER_USERNAME/sgproject:$service_name $DOCKER_USERNAME/sgproject:$service_name-$IMAGE_TAG
              echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
              docker push $DOCKER_USERNAME/sgproject:$service_name-$IMAGE_TAG
              cd $( [[ "$service_directory" == "frontend/studio-ghibli" || "$service_directory" == "backend"* ]] && echo "../.." || echo ".." )
            else
              echo "Directory $service_directory not found."
              exit 1
            fi
          }

          build_and_push "admin_frontend" "admin_frontend"
          build_and_push "frontend/studio-ghibli" "studio_ghibli_frontend"
          build_and_push "backend/gateway" "gateway"
          # build_and_push "backend/courses" "courses"
          # build-and-push "backend/enrollment" "enrollment"
          # build-and-push "backend/customers" "customers"
          # build-and-push "backend/users" "users"

  scan-docker-images:
    runs-on: ubuntu-latest
    needs: [build-and-push-images]
    continue-on-error: true 
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install Trivy
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update && sudo apt-get install trivy

      - name: Scan Docker Images with Trivy
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e

          scan_image() {
            local image_name=$1

            echo "Scanning image: $image_name"
            trivy image --exit-code 1 --severity HIGH,CRITICAL $image_name
          }

          # Example: Scan multiple Docker images
          scan_image "${DOCKER_USERNAME}/sgproject:admin_frontend-${IMAGE_TAG}"
          scan_image "${DOCKER_USERNAME}/sgproject:studio_ghibli_frontend-${IMAGE_TAG}"
          scan_image "${DOCKER_USERNAME}/sgproject:gateway-${IMAGE_TAG}"          

  iac-scanning:
    name: 'Terraform Scanning'
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v2

      - name: 'Set Up Terraform'
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 1.0.9

      - name: 'Install Terrascan'
        run: |
          curl -L https://github.com/tenable/terrascan/releases/download/v1.19.1/terrascan_1.19.1_Linux_x86_64.tar.gz -o terrascan.tar.gz
          tar -xzf terrascan.tar.gz
          chmod +x terrascan
          sudo mv terrascan /usr/local/bin/terrascan
          terrascan version

      - name: 'List Directory Contents'
        run: ls -la ./iac

      - name: 'Perform Terrascan'
        run: terrascan scan -i terraform -d ./iac
        continue-on-error: true 

  iac-build:
    name: 'Terraform Plan and Apply'
    needs: [iac-scanning, scan-docker-images]
    runs-on: ubuntu-latest
    outputs:
      target_ec2_ip: ${{ steps.get_ip.outputs.target_ip }}
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v2

      - name: 'Set Up Terraform'
        uses: hashicorp/setup-terraform@v1
        with:
          terraform_version: 1.0.9

      - name: 'Terraform Init'
        working-directory: ./iac
        run: terraform init

      - name: 'Terraform Validate'
        working-directory: ./iac
        run: terraform validate

      - name: 'Terraform Plan'
        working-directory: ./iac
        run: terraform plan

      - name: 'Terraform Apply'
        working-directory: ./iac
        id: get_ip
        run: |
          terraform apply -auto-approve
          instance_ip=$(terraform output instance_public_ip)
          match=$(echo "$instance_ip" | grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}')  # Extract digits and dots
          echo "::set-output name=target_ip::$match"

  deploy-containers:
    name: 'Deploy Docker Containers to EC2'
    needs: [build-and-push-images,iac-build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Install SSH Client
        run: sudo apt-get install -y openssh-client

      - name: Add SSH Key
        uses: webfactory/ssh-agent@v0.5.3
        with:
          ssh-private-key: ${{ secrets.AWS_SSH_PRIVATE_KEY }}

      - name: Copy Prometheus Configuration
        run: |
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=60 ./monitoring/prometheus.yml ubuntu@${{ needs.iac-build.outputs.target_ec2_ip }}:/home/ubuntu/prometheus.yml

      - name: Install Docker, Prometheus, Grafana, MySQL
        env:
          EC2_IP: ${{ needs.iac-build.outputs.target_ec2_ip }}
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=60 ubuntu@$EC2_IP << 'EOF'
            # Install Docker
            sudo apt-get update
            sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
            sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io jq

            # Start Docker service
            sudo systemctl start docker
            sudo systemctl enable docker

            # Verify Docker is running
            sudo systemctl status docker

            # Stage 1: Install Prometheus and Grafana
            sudo docker run -d -p 9090:9090 --name prometheus -v /home/ubuntu/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus
            sudo docker run -d -p 3000:3000 --name grafana grafana/grafana

            # Wait for Grafana to start
            sleep 30

            # Create Grafana API key
            GRAFANA_API_KEY=$(curl -s -X POST "http://admin:admin@localhost:3000/api/auth/keys" -H "Content-Type: application/json" -d '{"name":"API_KEY","role":"Admin"}' | jq -r '.key')

            # Configure Grafana to connect to Prometheus
            curl -s -X POST "http://admin:$GRAFANA_API_KEY@localhost:3000/api/datasources" -H "Content-Type: application/json" -d '{
              "name": "Prometheus",
              "type": "prometheus",
              "url": "http://localhost:9090",
              "access": "proxy",
              "isDefault": true
            }'

            # Check the status of Prometheus and Grafana containers
            sudo docker ps -a
          EOF

      - name: Deploy Application Docker Containers
        env:
          EC2_IP: ${{ needs.iac-build.outputs.target_ec2_ip }}
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          DOCKER_TOKEN: ${{ secrets.DOCKER_TOCKEN_NEW }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=60 ubuntu@$EC2_IP << 'EOF'
              echo "Deploying Docker containers..."

              # Ensure Docker credentials are set
              export DOCKER_USERNAME="$DOCKER_USERNAME"
              export DOCKER_TOKEN="$DOCKER_TOKEN"

              # Login to Docker registry
              echo "$DOCKER_TOKEN" | docker login -u "$DOCKER_USERNAME" --password-stdin

              # Pull and run your Docker containers (adjust ports and image names accordingly)
              sudo docker pull "$DOCKER_USERNAME/sgproject:admin_frontend-$IMAGE_TAG"
              sudo docker pull "$DOCKER_USERNAME/sgproject:studio_ghibli_frontend-$IMAGE_TAG"
              sudo docker pull "$DOCKER_USERNAME/sgproject:gateway-$IMAGE_TAG"
              
              sudo docker run -d -p 8080:8080 "$DOCKER_USERNAME/sgproject:admin_frontend-$IMAGE_TAG"
              sudo docker run -d -p 80:80 "$DOCKER_USERNAME/sgproject:studio_ghibli_frontend-$IMAGE_TAG"
              sudo docker run -d -p 8880:8880 "$DOCKER_USERNAME/sgproject:gateway-$IMAGE_TAG"

              # Check the status of the containers
              sudo docker ps -a
          EOF
